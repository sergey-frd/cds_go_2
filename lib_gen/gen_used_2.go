package lib_gen

import (   
     "fmt"
 	"sort"
     "encoding/json"
// //        "math"
//         "strconv"
// //        "time"
// //
// //    "log"
// //    "github.com/valyala/fastjson"
// //    "os" 
// //    "github.com/boltdb/bolt"
// //    "errors"
// 
// //  // "io/ioutil"
// //  //"bytes"
// //  //"runtime"
// //  //"encoding/gob"
// //  
// //  "math/rand"
// 
//     L "cds_go_2/lib"
     S "cds_go_2/config"

)


//  err = G.Gen_Ds_Ti(json_go,data,);  __err_panic(err)
//----------------------------------------------
//func Alloc_Um(byteValues  []byte, 
func Gen_Used_Ti(
    json_go  S.AutoGenerated,
    data       map[string]map[string]string,
    ) (err error) {


    p := fmt.Println
    // var err         error
    //var total       float64

    //var ct   S.City_STC
    //var Ds   S.Digital_Signage_STC
    var bti  S.Base_TI_STC
    //var odu  S.Ow_Ds_Used_STC
    //var dst  S.DS_TI_STC
    //var ct   S.User_Media_STC
    //var Ti   S.Time_Interval_STC

    //var iCounter int

    var keys []string


    // TimeAddDayMin  := json_go.Base.TimeAddDayMin
    // TimeAddDayMax  := json_go.Base.TimeAddDayMax
    // 
    // 
    // 
    // //var um   S.User_Media_STC
    // 
    // //............................................................
    // //Clip_Code_Country  := json_go.Base.ClipCodeCountry 
    // //Clip_Code_City     := json_go.Base.ClipCodeCity    
    // //
    // //ct.CnCt.ID_Country  = Clip_Code_Country
    // //ct.CnCt.ID_City     = Clip_Code_City
    // 
    // Time_Interval_Counter     := json_go.Base.TimeIntervalCounter    
    // 
    // 
    // 
    // CodeFreeUsers := jsongo.Base.CodeFreeUsers 
    // CodeFreeClips := jsongo.Base.CodeFreeClips 
    // 
    // //um.UsMd.IDUser  = strconv.Itoa(CodeFreeUsers)
    // //um.UsMd.IDMedia = strconv.Itoa(CodeFreeClips)
    // 
    // odu.Owdaydskey.UsMd.IDUser  = strconv.Itoa(CodeFreeUsers)  
    // odu.Owdaydskey.UsMd.IDMedia = strconv.Itoa(CodeFreeClips)  
    // //.............................

    tblname   := "Base_Ti"
    for k, _ := range data[tblname] {
        keys = append(keys, k)
    } // for k, v
    sort.Strings(keys)
    nnn := 0
    for _, k := range keys  {
      bytk := []byte(k)
      err = json.Unmarshal(bytk, &bti.Base_ti_key);  __err_panic(err)

      // if Ds.CnCtNbDs.CnCtNb != ps.UmNbDsTiSlKey.NbDsTiSlkey.NbDsTikey.CnCtNbDs.CnCtNb {
      //     continue
      // }

      dsvalue:= data[tblname][k]
      bytdsv := []byte(dsvalue)
      err = json.Unmarshal(bytdsv, &bti.Base_ti_val);  __err_panic(err)

      nnn  += 1

      //odu.Owdaydskey.CnCtNbDs  = dst.Dstikey.CnCtNbDs



        p(nnn,"bti =", bti)

       //!!!!!!!!!!!!!!!!!!!!
       break

    } // for , k := range keys 


//
//        bytk := []byte(k)
//        err = json.Unmarshal(bytk, &dst.Dstikey);  errpanic(err)
//
//        // if Ds.CnCtNbDs.CnCtNb != ps.UmNbDsTiSlKey.NbDsTiSlkey.NbDsTikey.CnCtNbDs.CnCtNb {
//        //     continue
//        // }
//
//        dsvalue:= data[tblname][k]
//        bytdsv := []byte(dsvalue)
//        err = json.Unmarshal(bytdsv, &dst.Index);  errpanic(err)
//
//        nnn  += 1
//
//        odu.Owdaydskey.CnCtNbDs  = dst.Dstikey.CnCtNbDs
//
//        p(nnn,"bti =", bti)
//        p(nnn,"odu =", odu)
//
//
//        for i := 1; i <= Time_Interval_Counter+1; i++ {
//
//
//            //Clip_4_ALL_Nb := L.Random(0, 2)
//
//            Ti.ID_Time_Interval = strconv.Itoa(i)
//            Ti.TiVl := data["Time_Interval"][Ti.ID_Time_Interval]
//            Slots, _ := strconv.Atoi(Ti.TiVl.Slots)
//            
//            n := 0
//            for ii := 1; ii <= Slots; ii++ {
//                n++
//            } // for ii := 1; ii <= Slots; ii++ 
//
//        } // for i := 1; i <= Time_Interval_Counter+1; i++ 
//
//        // //ps.UmNbDsTiSlKey.NbDsTiSlkey.NbDsTikey.CnCtNbDs = Ds.CnCtNbDs
//        // 
//        // currentTime := time.Now()   
//        // 
//        // // t := time.Now()
//        // t := time.Date(
//        //     currentTime.Year() ,
//        //     currentTime.Month(),
//        //     currentTime.Day()  ,
//        //     0   ,
//        //     0   ,
//        //     0   ,
//        //     0   , 
//        //     time.UTC,
//        //     )
//        // s := t.Add(time.Hour * time.Duration(TimeAddDayMin)*24)
//        // e := t.Add(time.Hour * time.Duration(TimeAddDayMax)*24)
//        // 
//        // dst.Dstikey.CnCtNbDs =  Ds.CnCtNbDs
//        // 
//        // 
//        // diff := e.Sub(s)
//        // //p("diff =",diff)
//        // //p("2 diff.Hours())        =",diff.Hours())
//        // 
//        // ctime := s
//        // iCounter = int(diff.Hours())
//        // //p("2 iCounter =",iCounter)
//        // 
//        // n := 0
//        // for i := 0; i < iCounter; i++ {
//        //     n++
//        //     ctime  = ctime.Add(time.Hour)
//        // 
//        //     dst.Dstikey.Ymdhkey.Year  =  ctime.Year()      
//        //     dst.Dstikey.Ymdhkey.Month =  int(ctime.Month())
//        //     dst.Dstikey.Ymdhkey.Day   =  ctime.Day()       
//        //     dst.Dstikey.Ymdhkey.Hour  =  ctime.Hour()      
//        // 
//        //     dst.Index = 1 
//        // 
//        //     encDstikey, err := json.Marshal(dst.Dstikey); errpanic(err)
//        // 
//        //     //p("dst =", dst)
//        //     dstIndex  := strconv.Itoa(dst.Index)
//        //     data["DsTi"][string(encDstikey)]  = dstIndex
//        // 
//        //     //p(i,c)
//        //     if e.Equal(ctime) {
//        //         //p("break i =",i)
//        //         break
//        //     } 
//        //     // p("ctime =",ctime)
//        // 
//        // 
//        //     //    //!!!!!!!!!!!!!!!!!!!!
//        // 
//        // } // for i
//
//
//        
//        //!!!!!!!!!!!!!!!!!!!!
//        break
// 
//     } // for , k := range keys 

    return  err

} // func allocow

