package lib_gen

import (   
//     "fmt"
 	"sort"
     "encoding/json"
// //        "math"
//         "strconv"
// //        "time"
// //
// //    "log"
// //    "github.com/valyala/fastjson"
// //    "os" 
// //    "github.com/boltdb/bolt"
// //    "errors"
// 
// //  // "io/ioutil"
// //  //"bytes"
// //  //"runtime"
// //  //"encoding/gob"
// //  
// //  "math/rand"

// 
     L "cds_go_2/lib"
     S "cds_go_2/config"

)


//  err = G.Gen_Ds_Ti(json_go,data,);  __err_panic(err)
//----------------------------------------------
//func Alloc_Um(byteValues  []byte, 
func Gen_Used_Ti(
    json_go  S.AutoGenerated,
    data       map[string]map[string]string,
    ) (err error) {


    //p := fmt.Println
    // var err         error
    //var total       float64

    //var ct   S.City_STC
    var Ds   S.Digital_Signage_STC
    var bti  S.Base_TI_STC
    //var odu  S.Ow_Ds_Used_STC
    //var dst  S.DS_TI_STC
    //var ct   S.User_Media_STC
    //var Ti   S.Time_Interval_STC

    //var iCounter int

    var      keys []string
    var      Slot       int
    var      Total_Slot int
    var      Total_Cost float64

    var    All_Used      int
    var    New_Free_Slot int
    var    Start_Indx    int
    var    Interv_Count  int
    var    Need_Used     int
    var    High_Slot     int


    // TimeAddDayMin  := json_go.Base.TimeAddDayMin
    // TimeAddDayMax  := json_go.Base.TimeAddDayMax
    // 
    // 
    // 
    // //var um   S.User_Media_STC
    // 
    // //............................................................
    // //Clip_Code_Country  := json_go.Base.ClipCodeCountry 
    // //Clip_Code_City     := json_go.Base.ClipCodeCity    
    // //
    // //ct.CnCt.ID_Country  = Clip_Code_Country
    // //ct.CnCt.ID_City     = Clip_Code_City
    // 
    // Time_Interval_Counter     := json_go.Base.TimeIntervalCounter    
    // 
    // 
    // 
    // CodeFreeUsers := jsongo.Base.CodeFreeUsers 
    // CodeFreeClips := jsongo.Base.CodeFreeClips 
    // 
    // //um.UsMd.IDUser  = strconv.Itoa(CodeFreeUsers)
    // //um.UsMd.IDMedia = strconv.Itoa(CodeFreeClips)
    // 
    // odu.Owdaydskey.UsMd.IDUser  = strconv.Itoa(CodeFreeUsers)  
    // odu.Owdaydskey.UsMd.IDMedia = strconv.Itoa(CodeFreeClips)  
    // //.............................


    Time_Interval_Counter  := json_go.Base.TimeIntervalCounter
    inxArr := make([]int, Time_Interval_Counter)


    tblname   := "Base_Ti"
    for k, _ := range data[tblname] {
        keys = append(keys, k)
    } // for k, v
    sort.Strings(keys)
    nnn := 0
    nn := 0
    for _, k := range keys  {
      bytk := []byte(k)
      err = json.Unmarshal(bytk, &bti.Base_ti_key);  __err_panic(err)

      // if Ds.CnCtNbDs.CnCtNb != ps.UmNbDsTiSlKey.NbDsTiSlkey.NbDsTikey.CnCtNbDs.CnCtNb {
      //     continue
      // }

      dsvalue:= data[tblname][k]
      bytdsv := []byte(dsvalue)
      err = json.Unmarshal(bytdsv, &bti.Base_ti_val);  __err_panic(err)

      nnn  += 1

      //odu.Owdaydskey.CnCtNbDs  = dst.Dstikey.CnCtNbDs

        All_Used      = L.Random(1,10)
        Need_Used     = L.Random(0,5)

        High_Slot     = L.Random(0,3)
        New_Free_Slot = L.Random(0,6)
        All_Used      = L.Random(0,5)
        Start_Indx    = L.Random(0,11)
        Interv_Count  = L.Random(2,12)
        Need_Used     = L.Random(0,5)

        if Need_Used == 0 { continue }

        nn  += 1

        //p(nn,nnn,All_Used,Start_Indx,Interv_Count,"bti =", New_Free_Slot, bti)

        Ds.CnCtNbDs = bti.Base_ti_key.CnCtNbDs

        ds_encoded, err := json.Marshal(Ds.CnCtNbDs)
        __err_panic(err)

        //ds_encoded, err := json.Marshal(Ds.CnCtNbDs);  
        //p(nnn,"ds_encoded =", ds_encoded)
        //p(nnn,"string ds_encoded =", string(ds_encoded))
        ds_value:= data["Digital_Signage"][string(ds_encoded)]
        //p(nnn,"ds_value =", ds_value)
        byt_dsv := []byte(ds_value)
        err = json.Unmarshal(byt_dsv, &Ds.DsVal)
        __err_panic(err)
        //p(nnn,"Ds.DsVal =", Ds.DsVal)

        //p(nnn,"Ds =", Ds)

        bti.Base_ti_val.Total_Cost     = 0 
        Total_Slot = 0
        Total_Cost = 0

        inxArr = bti.Base_ti_val.Index
        for h := 0; h < Time_Interval_Counter; h++ {

            if All_Used == 1 {
                inxArr[h] = 0
            } else { // if All_Used
                if High_Slot == 1 {
                    inxArr[h] = 6
                } else { // if High_Slot

                    if Start_Indx <= h && Start_Indx+Interv_Count >= h {
                    //if Start_Indx <= h {
                        inxArr[h] = New_Free_Slot
                        //p(h,Start_Indx,Start_Indx+Interv_Count,"inxArr[h] =", inxArr[h])
                    } //if Start_Indx 
                } // if High_Slot

                Slot = inxArr[h]
                _,_,slots,slot_price,err := Get_Price_Slots(h,Slot,Ds,json_go,data,);  __err_panic(err)
                Total_Slot +=  slots
                Total_Cost +=  slot_price

            } // if All_Used
        } // for h := 0; h < diff_days; h++ 

        bti.Base_ti_val.Index      = inxArr 
        //bti.Base_ti_val.Total_Slot = Time_Interval_Counter * 6
        bti.Base_ti_val.Total_Slot = Total_Slot
        bti.Base_ti_val.Total_Cost = Total_Cost


        enc_Base_ti_key, err := json.Marshal(bti.Base_ti_key); __err_panic(err)
        enc_Base_ti_val, err := json.Marshal(bti.Base_ti_val); __err_panic(err)

        //p("dst =", dst)
        //dst_Index  := strconv.Itoa(dst.Index)
        data["Base_Ti"][string(enc_Base_ti_key)]  = string(enc_Base_ti_val)


        //p(nn,nnn,All_Used,Start_Indx,Interv_Count,"upd =", New_Free_Slot, bti)


        //!!!!!!!!!!!!!!!!!!!!
        //if nnn >= 5 { break }

    } // for , k := range keys 


//
//        bytk := []byte(k)
//        err = json.Unmarshal(bytk, &dst.Dstikey);  errpanic(err)
//
//        // if Ds.CnCtNbDs.CnCtNb != ps.UmNbDsTiSlKey.NbDsTiSlkey.NbDsTikey.CnCtNbDs.CnCtNb {
//        //     continue
//        // }
//
//        dsvalue:= data[tblname][k]
//        bytdsv := []byte(dsvalue)
//        err = json.Unmarshal(bytdsv, &dst.Index);  errpanic(err)
//
//        nnn  += 1
//
//        odu.Owdaydskey.CnCtNbDs  = dst.Dstikey.CnCtNbDs
//
//        p(nnn,"bti =", bti)
//        p(nnn,"odu =", odu)
//
//
//        for i := 1; i <= Time_Interval_Counter+1; i++ {
//
//
//            //Clip_4_ALL_Nb := L.Random(0, 2)
//
//            Ti.ID_Time_Interval = strconv.Itoa(i)
//            Ti.TiVl := data["Time_Interval"][Ti.ID_Time_Interval]
//            Slots, _ := strconv.Atoi(Ti.TiVl.Slots)
//            
//            n := 0
//            for ii := 1; ii <= Slots; ii++ {
//                n++
//            } // for ii := 1; ii <= Slots; ii++ 
//
//        } // for i := 1; i <= Time_Interval_Counter+1; i++ 
//
//        // //ps.UmNbDsTiSlKey.NbDsTiSlkey.NbDsTikey.CnCtNbDs = Ds.CnCtNbDs
//        // 
//        // currentTime := time.Now()   
//        // 
//        // // t := time.Now()
//        // t := time.Date(
//        //     currentTime.Year() ,
//        //     currentTime.Month(),
//        //     currentTime.Day()  ,
//        //     0   ,
//        //     0   ,
//        //     0   ,
//        //     0   , 
//        //     time.UTC,
//        //     )
//        // s := t.Add(time.Hour * time.Duration(TimeAddDayMin)*24)
//        // e := t.Add(time.Hour * time.Duration(TimeAddDayMax)*24)
//        // 
//        // dst.Dstikey.CnCtNbDs =  Ds.CnCtNbDs
//        // 
//        // 
//        // diff := e.Sub(s)
//        // //p("diff =",diff)
//        // //p("2 diff.Hours())        =",diff.Hours())
//        // 
//        // ctime := s
//        // iCounter = int(diff.Hours())
//        // //p("2 iCounter =",iCounter)
//        // 
//        // n := 0
//        // for i := 0; i < iCounter; i++ {
//        //     n++
//        //     ctime  = ctime.Add(time.Hour)
//        // 
//        //     dst.Dstikey.Ymdhkey.Year  =  ctime.Year()      
//        //     dst.Dstikey.Ymdhkey.Month =  int(ctime.Month())
//        //     dst.Dstikey.Ymdhkey.Day   =  ctime.Day()       
//        //     dst.Dstikey.Ymdhkey.Hour  =  ctime.Hour()      
//        // 
//        //     dst.Index = 1 
//        // 
//        //     encDstikey, err := json.Marshal(dst.Dstikey); errpanic(err)
//        // 
//        //     //p("dst =", dst)
//        //     dstIndex  := strconv.Itoa(dst.Index)
//        //     data["DsTi"][string(encDstikey)]  = dstIndex
//        // 
//        //     //p(i,c)
//        //     if e.Equal(ctime) {
//        //         //p("break i =",i)
//        //         break
//        //     } 
//        //     // p("ctime =",ctime)
//        // 
//        // 
//        //     //    //!!!!!!!!!!!!!!!!!!!!
//        // 
//        // } // for i
//
//
//        
//        //!!!!!!!!!!!!!!!!!!!!
//        break
// 
//     } // for , k := range keys 

    return  err

} // func allocow

