package lib_gen

import (   
//    "fmt"
//        "math"
        "strconv"
        "time"
//
//    "log"
	"sort"
//    "github.com/valyala/fastjson"
//    "os" 
//    "github.com/boltdb/bolt"
//    "errors"

//  // "io/ioutil"
//  //"bytes"
//  //"runtime"
    "encoding/json"
//  //"encoding/gob"
//  
//  "math/rand"

//    L "cds_go_2/lib"
    S "cds_go_2/config"

)


//----------------------------------------------
func Get_Price_Slots(
    Time_Interval int,
    Slot          int,
    Ds            S.Digital_Signage_STC,
    json_go       S.AutoGenerated,
    data          map[string]map[string]string,
    ) (
     int,
     int,
     int,
     float64,
     error) {


    //p := fmt.Println
    //p("Get_Price_Slots Time_Interval =",Time_Interval)

    var Ti   S.Time_Interval_STC
    var err  error

    ID_Time_Interval := strconv.Itoa(Time_Interval)
    Ti.ID_Time_Interval = ID_Time_Interval

    ts_value:= data["Time_Interval"][ID_Time_Interval]
    byt_tsv := []byte(ts_value)
    err = json.Unmarshal(byt_tsv, &Ti.TiVl);  __err_panic(err)
    slots, _ := strconv.Atoi(Ti.TiVl.Slots)

    price, _           := strconv.ParseFloat(data["Price"][strconv.Itoa(Slot)], 64)
    DS_Perc_Quality, _ := strconv.Atoi(Ds.DsVal.DS_Perc_Quality)
    TI_Price, _        := strconv.Atoi(Ti.TiVl.Price)
    TI_People, _       := strconv.Atoi(Ti.TiVl.D_Sign_People)
    DS_TI_Price        := float64(TI_Price)*float64(DS_Perc_Quality)/100
    Slot_Price         := price*DS_TI_Price 

    return TI_People,TI_Price,slots,Slot_Price,err

} // func Get_Price_Slots

//----------------------------------------------
//  err = G.Gen_Ds_Ti2(json_go,data,);  __err_panic(err)
//----------------------------------------------
func Gen_Ds_Ti2(
    json_go  S.AutoGenerated,
    data       map[string]map[string]string,
    ) (err error) {


    //p := fmt.Println
    // var err         error
    //var total       float64

    //var dst  S.DS_TI_STC
    var      Ds         S.Digital_Signage_STC
    var      bti        S.Base_TI_STC
    var      Slot       int
    var      Total_Slot int
    var      Total_Cost float64
    //var iCounter int

    var keys []string


    TimeAddDayMin          := json_go.Base.TimeAddDayMin
    TimeAddDayMax          := json_go.Base.TimeAddDayMax
    Time_Interval_Counter  := json_go.Base.TimeIntervalCounter
    //p("Time_Interval_Counter =",Time_Interval_Counter)

    inxArr := make([]int, Time_Interval_Counter)

    for k, _ := range data["Digital_Signage"] {
        keys = append(keys, k)
    } // for k, v
    sort.Strings(keys)
    nnn := 0
    for _, k := range keys  {

        byt_k := []byte(k)
        err = json.Unmarshal(byt_k, &Ds.CnCtNbDs);  __err_panic(err)

        // if Ds.CnCtNbDs.CnCtNb != ps.UmNbDsTiSl_Key.NbDsTiSl_key.NbDsTi_key.CnCtNbDs.CnCtNb {
        //     continue
        // }

        ds_value:= data["Digital_Signage"][k]
        byt_dsv := []byte(ds_value)
        err = json.Unmarshal(byt_dsv, &Ds.DsVal);  __err_panic(err)

        nnn  += 1


        //ps.UmNbDsTiSl_Key.NbDsTiSl_key.NbDsTi_key.CnCtNbDs = Ds.CnCtNbDs

        currentTime := time.Now()   

        // t := time.Now()
        t := time.Date(
            currentTime.Year() ,
            currentTime.Month(),
            currentTime.Day()  ,
            0   ,
            0   ,
            0   ,
            0   , 
            time.UTC,
            )
        s := t.Add(time.Hour * time.Duration(TimeAddDayMin-1)*24)
        e := t.Add(time.Hour * time.Duration(TimeAddDayMax+1)*24)
  
        //dst.Ds_ti_key.CnCtNbDs =  Ds.CnCtNbDs
        bti.Base_ti_key.CnCtNbDs =  Ds.CnCtNbDs
        //p(nnn,"Ds =", Ds,s,e)


        diff := e.Sub(s)
        diff_Hours := int(diff.Hours())
        //p("diff_Hours =",diff_Hours)
        diff_days := diff_Hours/Time_Interval_Counter
        //p("diff_days  =",diff_days)

        c_day := s
        for d := 0; d < diff_days; d++ {

            bti.Base_ti_key.Ymd_key.Year   =  c_day.Year()       
            bti.Base_ti_key.Ymd_key.Month  =  int(c_day.Month()) 
            bti.Base_ti_key.Ymd_key.Day    =  c_day.Day()    

            bti.Base_ti_val.Total_Cost     = 0 
            Total_Slot = 0
            Total_Cost = 0

            for h := 0; h < Time_Interval_Counter; h++ {
                Slot      = 1
                inxArr[h] = Slot

                _,_,slots,slot_price,err := Get_Price_Slots(h,Slot,Ds,json_go,data,);  __err_panic(err)
                // ID_Time_Interval := strconv.Itoa(h)
                // Ti.ID_Time_Interval = ID_Time_Interval
                // ts_value:= data["Time_Interval"][ID_Time_Interval]
                // byt_tsv := []byte(ts_value)
                // err = json.Unmarshal(byt_tsv, &Ti.TiVl);  __err_panic(err)
                // Slots, _ := strconv.Atoi(Ti.TiVl.Slots)
                Total_Slot +=  slots
                Total_Cost +=  slot_price

            } // for h := 0; h < diff_days; h++ 

            bti.Base_ti_val.Index      = inxArr 
            //bti.Base_ti_val.Total_Slot = Time_Interval_Counter * 6
            bti.Base_ti_val.Total_Slot = Total_Slot
            bti.Base_ti_val.Total_Cost = Total_Cost
  

            enc_Base_ti_key, err := json.Marshal(bti.Base_ti_key); __err_panic(err)
            enc_Base_ti_val, err := json.Marshal(bti.Base_ti_val); __err_panic(err)

            //p("dst =", dst)
            //dst_Index  := strconv.Itoa(dst.Index)
            data["Base_Ti"][string(enc_Base_ti_key)]  = string(enc_Base_ti_val)



            //!!!!!!!!!!!!!!!!!!!!
            //break

            c_day  = c_day.Add(time.Hour*24)

        } // for d := 0; d < diff_days; d++ 
        
        //!!!!!!!!!!!!!!!!!!!!
        //break

    } // for _, k := range keys 

    return  err

} // func alloc_ow

