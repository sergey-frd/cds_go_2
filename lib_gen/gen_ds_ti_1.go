package lib_gen

import (   
//    "fmt"
//        "math"
        "strconv"
        "time"
//
//    "log"
	"sort"
//    "github.com/valyala/fastjson"
//    "os" 
//    "github.com/boltdb/bolt"
//    "errors"

//  // "io/ioutil"
//  //"bytes"
//  //"runtime"
    "encoding/json"
//  //"encoding/gob"
//  
//  "math/rand"

//    L "cds_go_2/lib"
    S "cds_go_2/config"

)


//  err = G.Gen_Ds_Ti(json_go,data,);  __err_panic(err)
//----------------------------------------------
//func Alloc_Um(byteValues  []byte, 
func Gen_Ds_Ti(
    json_go  S.AutoGenerated,
    data       map[string]map[string]string,
    ) (err error) {


    //p := fmt.Println
    // var err         error
    //var total       float64

    var Ds   S.Digital_Signage_STC
    var dst  S.DS_TI_STC

    var iCounter int

    var keys []string


    TimeAddDayMin  := json_go.Base.TimeAddDayMin
    TimeAddDayMax  := json_go.Base.TimeAddDayMax


    for k, _ := range data["Digital_Signage"] {
        keys = append(keys, k)
    } // for k, v
    sort.Strings(keys)
    nnn := 0
    for _, k := range keys  {

        byt_k := []byte(k)
        err = json.Unmarshal(byt_k, &Ds.CnCtNbDs);  __err_panic(err)

        // if Ds.CnCtNbDs.CnCtNb != ps.UmNbDsTiSl_Key.NbDsTiSl_key.NbDsTi_key.CnCtNbDs.CnCtNb {
        //     continue
        // }

        ds_value:= data["Digital_Signage"][k]
        byt_dsv := []byte(ds_value)
        err = json.Unmarshal(byt_dsv, &Ds.DsVal);  __err_panic(err)

        nnn  += 1


        //ps.UmNbDsTiSl_Key.NbDsTiSl_key.NbDsTi_key.CnCtNbDs = Ds.CnCtNbDs

        currentTime := time.Now()   

        // t := time.Now()
        t := time.Date(
            currentTime.Year() ,
            currentTime.Month(),
            currentTime.Day()  ,
            0   ,
            0   ,
            0   ,
            0   , 
            time.UTC,
            )
        s := t.Add(time.Hour * time.Duration(TimeAddDayMin)*24)
        e := t.Add(time.Hour * time.Duration(TimeAddDayMax)*24)
  
        dst.Ds_ti_key.CnCtNbDs =  Ds.CnCtNbDs
        //p(nnn,"Ds =", Ds,s,e)


        diff := e.Sub(s)
        //p("diff =",diff)
        //p("2 diff.Hours())        =",diff.Hours())
        
        c_time := s
        iCounter = int(diff.Hours())
        //p("2 iCounter =",iCounter)

        n := 0
        for i := 0; i < iCounter; i++ {
            n++
            c_time  = c_time.Add(time.Hour)

            dst.Ds_ti_key.Ymdh_key.Year  =  c_time.Year()      
            dst.Ds_ti_key.Ymdh_key.Month =  int(c_time.Month())
            dst.Ds_ti_key.Ymdh_key.Day   =  c_time.Day()       
            dst.Ds_ti_key.Ymdh_key.Hour  =  c_time.Hour()      

            dst.Index = 1 

            enc_Ds_ti_key, err := json.Marshal(dst.Ds_ti_key); __err_panic(err)

            //p("dst =", dst)
            dst_Index  := strconv.Itoa(dst.Index)
            data["Ds_Ti"][string(enc_Ds_ti_key)]  = dst_Index

            //p(i,c)
            if e.Equal(c_time) {
                //p("break i =",i)
                break
            } 
            // p("c_time =",c_time)

            //err = Gen_Lvl_Sl(byteValues,data,ps,um,c,);  __err_panic(err)
            //err = Gen_Lvl_Ti(byteValues,data,ps,um,Ds,c,);  __err_panic(err)

            //    //!!!!!!!!!!!!!!!!!!!!

        } // for i


        // //fmt.Println("      ds ps =", ps)
        // //fmt.Println("      um.UsMdVl            =", um.UsMdVl)
        // //fmt.Println("      um.UsMdVl.Start_time =", um.UsMdVl.Start_time)
        // //fmt.Println("      um.UsMdVl.End_time   =", um.UsMdVl.End_time  )
        // 
        // //year, month, day, hour, min, sec := L.Diff(um.UsMdVl.Start_time, um.UsMdVl.End_time)
        // //fmt.Printf("      diff = %d years, %d months, %d days, %d hours, %d mins and %d seconds\n",
        // //    year, month, day, hour, min, sec)
        // // err = Gen_Lvl_Ti(byteValues,data,ps,);  __err_panic(err)
        // 
        // diff := um.UsMdVl.End_time.Sub(um.UsMdVl.Start_time)
        // //p("diff =",diff)
        // //p("diff.Hours())        =",diff.Hours())
        // //p("diff.Minutes())      =",diff.Minutes())
        // //p("diff.Seconds())      =",diff.Seconds())
        // 
        // t := time.Date(
        //     um.UsMdVl.Start_time.Year() ,
        //     um.UsMdVl.Start_time.Month(),
        //     um.UsMdVl.Start_time.Day()  ,
        //     0   ,
        //     0   ,
        //     0   ,
        //     0   , 
        //     time.UTC,
        //     )
        // 
        // e := time.Date(
        //     um.UsMdVl.End_time.Year() ,
        //     um.UsMdVl.End_time.Month(),
        //     um.UsMdVl.End_time.Day()  ,
        //     0   ,
        //     0   ,
        //     0   ,
        //     0   , 
        //     time.UTC,
        //     )
        // 
        // e  = e.Add(time.Hour * 24)
        // diff = e.Sub(t)
        // //p("2 t =",t)
        // //p("2 e =",e)
        // //p("2 diff =",diff)
        // //p("2 diff.Hours())        =",diff.Hours())
        // 
        // c := t
        // iCounter = int(diff.Hours())
        // //p("2 iCounter =",iCounter)
        // 
        // n := 0
        // for i := 0; i < iCounter; i++ {
        //     n++
        //     c  = c.Add(time.Hour)
        // 
        //     //p(i,c)
        //     if um.UsMdVl.End_time.Equal(c) {
        //         //p("break i =",i)
        //         break
        //     } 
        //     //p("c =",c)
        //     //err = Gen_Lvl_Sl(byteValues,data,ps,um,c,);  __err_panic(err)
        //     err = Gen_Lvl_Ti(byteValues,data,ps,um,Ds,c,);  __err_panic(err)
        // 
        //     //    //!!!!!!!!!!!!!!!!!!!!
        // 
        // } // for i
        // 
        // //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        // //if nnn >=5 { break }
        // //p("3 c =",c)
        // 
        
        //!!!!!!!!!!!!!!!!!!!!
        //break

    } // for _, k := range keys 

    return  err

} // func alloc_ow

