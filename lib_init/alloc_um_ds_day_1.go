package lib_init

import (   
//    "fmt"
    "sort"
    "encoding/json"
    "time"

// //        "math"
//         "strconv"
// //        "time"
// //
// //    "log"
// //    "github.com/valyala/fastjson"
// //    "os" 
// //    "github.com/boltdb/bolt"
// //    "errors"
// 
// //  // "io/ioutil"
// //  //"bytes"
// //  //"runtime"
// //  //"encoding/gob"
// //  
// //  "math/rand"

// 
//     L "cds_go_2/lib"
     S "cds_go_2/config"

)


//----------------------------------------------
func alloc_um_ds_day(
    json_go    S.AutoGenerated,
    data       map[string]map[string]string,
    um         S.User_Media_STC,
    ud         S.Um_Ds_STC,
    Cost_koef  float64,
    ) ( error) {


    var      err error

    //var Total_Slot    int
    //var Total_Cost    float64

    var bti  S.Base_TI_STC
    var      keys []string

     t := time.Date(
         um.UsMdVl.Start_time.Year() ,
         um.UsMdVl.Start_time.Month(),
         um.UsMdVl.Start_time.Day()  ,
         0   ,
         0   ,
         0   ,
         0   , 
         time.UTC,
         )
 
     //t  = t.Add(time.Hour * -24)

     e := time.Date(
         um.UsMdVl.End_time.Year() ,
         um.UsMdVl.End_time.Month(),
         um.UsMdVl.End_time.Day()  ,
         0   ,
         0   ,
         0   ,
         0   , 
         time.UTC,
         )

    // Total_Slot    = 0
    // Total_Cost    = 0


    tblname   := "Base_Ti"
    for k, _ := range data[tblname] {
        keys = append(keys, k)
    } // for k, v
    sort.Strings(keys)
    nnn := 0
    //nn := 0
    for _, k := range keys  {
      bytk := []byte(k)
      err = json.Unmarshal(bytk, &bti.Base_ti_key);  __err_panic(err)


      dsvalue:= data[tblname][k]
      bytdsv := []byte(dsvalue)
      err = json.Unmarshal(bytdsv, &bti.Base_ti_val);  __err_panic(err)

      nnn  += 1
      if bti.Base_ti_key.CnCtNbDs != ud.Um_ds_key.Ds_key { continue }

        c := time.Date(
             bti.Base_ti_key.Ymd_key.Year ,
             time.Month(bti.Base_ti_key.Ymd_key.Month),
             bti.Base_ti_key.Ymd_key.Day  ,
             0   ,
             0   ,
             0   ,
             0   , 
             time.UTC,
         )

        if c.Before(t) { continue }
        if c.After(e)  { continue }


        err  := Alloc_Ti(json_go, data, um, ud, bti, Cost_koef,);    __err_panic(err)


        // fmt.Println(nnn,"bti =", bti)
        // //Total_Slot    += bti.Base_ti_val.Total_Slot
        // //Total_Cost    += bti.Base_ti_val.Total_Cost
        // 
        // Media_Ds_Day_Cost := bti.Base_ti_val.Total_Cost / Cost_koef
        // fmt.Println(nnn,"Media_Ds_Day_Cost =", Media_Ds_Day_Cost)

        if nnn >= 1 { break }

    } // for , k := range keys 

    //return  Total_Slot,Total_Cost,err
    return  err

} // func allocow

