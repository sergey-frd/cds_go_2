package lib_init

import (   
    "fmt"
    "encoding/json"
    "sort"
    "strings"
    "strconv"



//     "sort.Interface"
// //        "math"
// //        "time"
// //
// //    "log"
// //    "github.com/valyala/fastjson"
// //    "os" 
// //    "github.com/boltdb/bolt"
// //    "errors"
// 
// //  // "io/ioutil"
// //  //"bytes"
// //  //"runtime"
// //  //"encoding/gob"
// //  
// //  "math/rand"

// 
//     L "cds_go_2/lib"
     S "cds_go_2/config"
//     G "cds_go_2/lib_gen"
)


// type Ta_Lst []S.Time_Int_STC
// 
// func (d Ta_Lst) Len() int           { return len(d) }
// //func (d Ta_Lst) Less(i, j int) bool { return d[i] > d[j]}
// func (d Ta_Lst) Swap(i, j int)      { d[i], d[j] = d[j], d[i] }



//----------------------------------------------
func Alloc_Ti(
    json_go            S.AutoGenerated,
    data               map[string]map[string]string,    
    um                 S.User_Media_STC,
    ud                 S.Um_Ds_STC,
    bti                S.Base_TI_STC,
    Media_Ds_Day_Cost  float64,
    rs                 S.Result_STC, 
    ) (S.Base_TI_STC,  S.Result_STC) {

    var err    error
    var Ds     S.Digital_Signage_STC
    //var ta     S.Time_Int_STC
    // var Slot        int
    // var Start_Hour  int 
    // var End_Hour    int 
    var total       float64
    // var total_slot  int

    //if bti.Base_ti_val.Total_Cost == 0 { return  err }
    if bti.Base_ti_val.Total_Cost == 0 { return bti, rs  }

    Time_Interval_Counter := json_go.Base.TimeIntervalCounter
    inxArr                := make([]int,             Time_Interval_Counter)
    rs.Result_val.Hours    = make([]S.Result_DETAIL, Time_Interval_Counter)
    rs.Result_key.Ymd_key  = bti.Base_ti_key.Ymd_key


    //fmt.Println("rs =", rs)


    //fmt.Println("Alloc_Ti bti =", bti)
    //Media_Ds_Day_Cost := bti.Base_ti_val.Total_Cost / Cost_koef
    fmt.Println("Media_Ds_Day_Cost =", Media_Ds_Day_Cost)

    rs.Result_val.Plan  = Media_Ds_Day_Cost


    Ds.CnCtNbDs = bti.Base_ti_key.CnCtNbDs
    ds_encoded, err := json.Marshal(Ds.CnCtNbDs)
    __err_panic(err)

    ds_value:= data["Digital_Signage"][string(ds_encoded)]
    byt_dsv := []byte(ds_value)
    err      = json.Unmarshal(byt_dsv, &Ds.DsVal)
    __err_panic(err)
    //fmt.Println("Ds =", Ds)


    // total       := 0
    // total_slot  := 0
    // Start_Hour  := 0
    // End_Hour    := 0

    inxArr = bti.Base_ti_val.Index


    _, Ta_Lst, err := Get_Price_Array(Ds,json_go,data,inxArr,);  __err_panic(err)
    //fmt.Println("Alloc_Ti Ta_Map  ",Ta_Map)
    //fmt.Println("Alloc_Ti Ta_Map  len =",len(Ta_Map))
    fmt.Println("Alloc_Ti Ta_Lst  len =",len(Ta_Lst))
    //fmt.Println("Alloc_Ti Ta_Lst      =",Ta_Lst)


    //sort.Sort(Ta_Lst)sort.Sort(sort.Reverse(fooAscending(s)))
    //sort.Sort(sort.Reverse(Ta_Lst))
    sort.Strings(Ta_Lst)        
    //sort.Sort(sort.Reverse(sort.IntSlice(Ta_Lst)))



    total       = 0
    n := 0
    for _, d := range Ta_Lst {
        n++
    
        result := strings.Split(d, ",")

        TI_People, _        := strconv.Atoi(result[1])
        ID_Time_Interval, _ := strconv.Atoi(result[2])
        Slot_Price, _       := strconv.ParseFloat(result[3], 64)
        price, _            := strconv.Atoi(result[4])
        slots, _            := strconv.Atoi(result[5])

        // ta.Time_int_key.D_Sign_People     = TI_People
        // ta.Time_int_key.Slot_Price        = price
        // ta.Time_int_key.ID_Time_Interval  = ID_Time_Interval

        //fmt.Println(TI_People,ID_Time_Interval,Slot_Price,price,Ta_Map[ta.Time_int_key])      
        //fmt.Println(TI_People,ID_Time_Interval,Slot_Price,price)      
        // fmt.Println(ta.Time_int_key)      
        //fmt.Println(Ta_Map[ta.Time_int_key])      
                 


        if  total + Slot_Price < Media_Ds_Day_Cost {

            
            rs.Result_val.Hours[ID_Time_Interval].ID_Time_Interval = ID_Time_Interval
            rs.Result_val.Hours[ID_Time_Interval].Paid        = Slot_Price
            rs.Result_val.Hours[ID_Time_Interval].Count_Media = 60
            rs.Result_val.Hours[ID_Time_Interval].People      = TI_People
            rs.Result_val.Hours[ID_Time_Interval].Slots       = slots

            rs.Result_val.Count_Media   += rs.Result_val.Hours[ID_Time_Interval].Count_Media
            rs.Result_val.People        += rs.Result_val.Hours[ID_Time_Interval].People


            fmt.Println(total, TI_People,ID_Time_Interval,Slot_Price,price,slots)      
            total      += Slot_Price
            //total_slot += slots
        } //if  total + slot_price < Media_Ds_Day_Cost 


    }

    //fmt.Println("***** total =",total_slot, total,Start_Hour,End_Hour)
    fmt.Println("***** total =",total)

    rs.Result_val.Paid   = total
    rs.Result_val.Delta  = rs.Result_val.Plan -rs.Result_val.Paid 

    fmt.Println("rs =", rs)

    // for h := 0; h < Time_Interval_Counter; h++ {
    // 
    //     Slot = inxArr[h]
    //     //fmt.Println("inxArr[h] =", inxArr[h])
    //     //slots,slot_price,err := G.Get_Price_Slots(h,Slot,Ds,json_go,data,);  __err_panic(err)
    //     _,_,_,slot_price,err := G.Get_Price_Slots(h,Slot,Ds,json_go,data,);  __err_panic(err)
    // 
    //     if slot_price == 0 {continue}
    //     if Slot       == 0 {continue}
    //     if Start_Hour == 0 {Start_Hour = h}
    // 
    //     fmt.Println("inxArr[h],slots,slot_price =",total_slot,total,h, inxArr[h],slot_price)
    // 
    //     if  total + slot_price < Media_Ds_Day_Cost {
    //         total      += slot_price
    //         //total_slot += slots
    //         total_slot += 1
    //     } else { //if  total + slot_price < Media_Ds_Day_Cost 
    //         End_Hour    = h
    //         fmt.Println("***** total =",total_slot, total,Start_Hour,End_Hour)
    //         break
    // 
    //     } //if  total + slot_price < Media_Ds_Day_Cost 
    // 
    // 
    // } // for h := 0; h < diff_days; h++ 

    return bti, rs

} // func allocow

