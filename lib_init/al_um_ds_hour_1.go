package lib_init

import (   
     "fmt"
     "encoding/json"
     "sort"
//     "sort.Interface"
// //        "math"
//         "strconv"
// //        "time"
// //
// //    "log"
// //    "github.com/valyala/fastjson"
// //    "os" 
// //    "github.com/boltdb/bolt"
// //    "errors"
// 
// //  // "io/ioutil"
// //  //"bytes"
// //  //"runtime"
// //  //"encoding/gob"
// //  
// //  "math/rand"

// 
//     L "cds_go_2/lib"
     S "cds_go_2/config"
     G "cds_go_2/lib_gen"
)


// type Ta_Lst []S.Time_Int_STC
// 
// func (d Ta_Lst) Len() int           { return len(d) }
// //func (d Ta_Lst) Less(i, j int) bool { return d[i] > d[j]}
// func (d Ta_Lst) Swap(i, j int)      { d[i], d[j] = d[j], d[i] }



//----------------------------------------------
func Alloc_Ti(
    json_go    S.AutoGenerated,
    data       map[string]map[string]string,    
    um         S.User_Media_STC,
    ud         S.Um_Ds_STC,
    bti        S.Base_TI_STC,
    Cost_koef  float64,
    ) (err error) {





    var Ds          S.Digital_Signage_STC
    var Slot        int
    var Start_Hour  int 
    var End_Hour    int 
    var total       float64
    var total_slot  int

    if bti.Base_ti_val.Total_Cost == 0 { return  err }

    Time_Interval_Counter  := json_go.Base.TimeIntervalCounter
    inxArr := make([]int, Time_Interval_Counter)

    fmt.Println("Alloc_Ti bti =", bti)
    Media_Ds_Day_Cost := bti.Base_ti_val.Total_Cost / Cost_koef
    fmt.Println("Media_Ds_Day_Cost =", Media_Ds_Day_Cost)

    Ds.CnCtNbDs = bti.Base_ti_key.CnCtNbDs
    ds_encoded, err := json.Marshal(Ds.CnCtNbDs)
    __err_panic(err)

    ds_value:= data["Digital_Signage"][string(ds_encoded)]
    byt_dsv := []byte(ds_value)
    err = json.Unmarshal(byt_dsv, &Ds.DsVal)
    __err_panic(err)
    //fmt.Println("Ds =", Ds)


    total = 0
    total_slot   = 0

    Start_Hour  = 0
    End_Hour    = 0

    inxArr = bti.Base_ti_val.Index


    Ta_Map, Ta_Lst, err := Get_Price_Array(Ds,json_go,data,inxArr,);  __err_panic(err)
    fmt.Println("Alloc_Ti Ta_Map  len =",len(Ta_Map))
    fmt.Println("Alloc_Ti Ta_Lst  len =",len(Ta_Lst))
    //fmt.Println("Alloc_Ti Ta_Lst      =",Ta_Lst)


    //sort.Sort(Ta_Lst)sort.Sort(sort.Reverse(fooAscending(s)))
    //sort.Sort(sort.Reverse(Ta_Lst))
    sort.Strings(Ta_Lst)        
    //sort.Sort(sort.Reverse(sort.IntSlice(Ta_Lst)))



    for _, d := range Ta_Lst {
    
        //fmt.Println("D_Sign_People=",d.Time_int_key.D_Sign_People)
        // if d.D_Sign_People == "0" {continue}
        // if d.Slot_Price    == "0" {continue}
    
        fmt.Println(d)
    }



    for h := 0; h < Time_Interval_Counter; h++ {

        Slot = inxArr[h]
        //fmt.Println("inxArr[h] =", inxArr[h])
        //slots,slot_price,err := G.Get_Price_Slots(h,Slot,Ds,json_go,data,);  __err_panic(err)
        _,_,_,slot_price,err := G.Get_Price_Slots(h,Slot,Ds,json_go,data,);  __err_panic(err)

        if slot_price == 0 {continue}
        if Slot       == 0 {continue}
        if Start_Hour == 0 {Start_Hour = h}

        fmt.Println("inxArr[h],slots,slot_price =",total_slot,total,h, inxArr[h],slot_price)

        if  total + slot_price < Media_Ds_Day_Cost {
            total      += slot_price
            //total_slot += slots
            total_slot += 1
        } else { //if  total + slot_price < Media_Ds_Day_Cost 
            End_Hour    = h
            fmt.Println("***** total =",total_slot, total,Start_Hour,End_Hour)
            break

        } //if  total + slot_price < Media_Ds_Day_Cost 


    } // for h := 0; h < diff_days; h++ 

    return  err

} // func allocow

