package lib_init

import (   
     "fmt"
     "encoding/json"
// 	"sort"
// //        "math"
//         "strconv"
// //        "time"
// //
// //    "log"
// //    "github.com/valyala/fastjson"
// //    "os" 
// //    "github.com/boltdb/bolt"
// //    "errors"
// 
// //  // "io/ioutil"
// //  //"bytes"
// //  //"runtime"
// //  //"encoding/gob"
// //  
// //  "math/rand"

// 
//     L "cds_go_2/lib"
     S "cds_go_2/config"
     G "cds_go_2/lib_gen"
)


//----------------------------------------------



//----------------------------------------------
func Alloc_Ti(
    json_go    S.AutoGenerated,
    data       map[string]map[string]string,    
    um         S.User_Media_STC,
    ud         S.Um_Ds_STC,
    bti        S.Base_TI_STC,
    Cost_koef  float64,
    ) (err error) {


    var Ds          S.Digital_Signage_STC
    var Slot        int
    var total       float64
    var total_slot  int

    if bti.Base_ti_val.Total_Cost == 0 { return  err }

    Time_Interval_Counter  := json_go.Base.TimeIntervalCounter
    inxArr := make([]int, Time_Interval_Counter)

    fmt.Println("Alloc_Ti bti =", bti)
    Media_Ds_Day_Cost := bti.Base_ti_val.Total_Cost / Cost_koef
    fmt.Println("Media_Ds_Day_Cost =", Media_Ds_Day_Cost)

    Ds.CnCtNbDs = bti.Base_ti_key.CnCtNbDs
    ds_encoded, err := json.Marshal(Ds.CnCtNbDs)
    __err_panic(err)

    ds_value:= data["Digital_Signage"][string(ds_encoded)]
    byt_dsv := []byte(ds_value)
    err = json.Unmarshal(byt_dsv, &Ds.DsVal)
    __err_panic(err)
    //fmt.Println("Ds =", Ds)


    total = 0
    total_slot   = 0
    inxArr = bti.Base_ti_val.Index
    for h := 0; h < Time_Interval_Counter; h++ {

        Slot = inxArr[h]
        //fmt.Println("inxArr[h] =", inxArr[h])
        slots,slot_price,err := G.Get_Price_Slots(h,Slot,Ds,json_go,data,);  __err_panic(err)
        //slots,slot_price,err := Get_Price_Slots2(h,Slot,Ds,json_go,data,);  __err_panic(err)
        fmt.Println("inxArr[h],slots,slot_price =",total_slot,total,h, inxArr[h],slots,slot_price)

        if  total + slot_price < Media_Ds_Day_Cost {
            total      += slot_price
            total_slot += slots
        } else { //if  total + slot_price < Media_Ds_Day_Cost 
            fmt.Println("***** total =",total_slot, total)
            break

        } //if  total + slot_price < Media_Ds_Day_Cost 


    } // for h := 0; h < diff_days; h++ 

    return  err

} // func allocow

