package lib_init

import (   
    "fmt"
	"log"
	"sort"
    "encoding/json"
//    "github.com/valyala/fastjson"
//    "os" 
//    "github.com/boltdb/bolt"
//    "errors"

//    "strconv"
//  // "io/ioutil"
//  //"bytes"
//  //"runtime"
//  //"encoding/gob"
//  
//  "time"
//  "math/rand"
//
//    L "cds_go_2/lib"
    S "cds_go_2/config"
)
//---------------------------------------------------------------
func __err_panic(err error) {
	if err != nil {
		log.Fatal(err)
		panic(err)
	}
}
//----------------------------------------------
func Init_Um2(
    json_go         S.AutoGenerated,
    byteValues      []byte, 
    data            map[string]map[string]string,
    TotalDict       map[string]map[string]float64,
    )  (err error) {

    var tbl_name   string
    var um         S.User_Media_STC

    var u_keys []string
    tbl_name   = "User_Media"
    for u_k, _ := range data[tbl_name] {
        u_keys = append(u_keys, u_k)
    } // for k, v
    sort.Strings(u_keys)  // or sort.Ints(keys), sort.Sort(...), etc., per <K>

    for _, u_k := range u_keys  {
        u_v := data[tbl_name][u_k]

        //.................................................
        byt_u_k := []byte(u_k)
        //err := json.Unmarshal(byt_ds, &k_Ds)
        err = json.Unmarshal(byt_u_k, &um.UsMd)
        if err != nil {
            fmt.Println("There was an error:", err)
        }

        byt_u_v := []byte(u_v)
        err = json.Unmarshal(byt_u_v, &um.UsMdVl)
        if err != nil {
            fmt.Println("There was an error:", err)
        }
        fmt.Println("um =", um)


        //data["Results"][rs.Result_key] = [rs.Result_key]

        Um_base_cost, err := Init_Um_Ds2(json_go,byteValues,data,TotalDict,um,);  __err_panic(err)
        //fmt.Println("Um_base_cost =", Um_base_cost)

        err = Alloc_Um_Ds2(json_go,byteValues,data,TotalDict,um,Um_base_cost,);  __err_panic(err)
        //fmt.Println("Um_Total_Cost =", Um_Total_Cost)

        //---------------------------------------------------

        //!!!!!!!!!!!!!!!!!!!!
        break

    } // for _, k := range keys  {

    return  err

} // func 
